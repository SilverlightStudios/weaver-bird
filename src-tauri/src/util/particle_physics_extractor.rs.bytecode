/// Particle Physics Extractor
///
/// Extracts particle physics data (lifetime, gravity, size, etc.) from
/// Minecraft's decompiled source code using Mojang's official mappings.
///
/// This data is NOT bundled with the app - it's extracted on-demand
/// from the user's Minecraft installation.
use anyhow::{anyhow, Context, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::io::{BufRead, BufReader};
use std::path::{Path, PathBuf};

use super::bytecode_parser::extract_bytecode_info;
use super::zip::extract_zip_entry;

/// Extracted particle physics data
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ExtractedParticlePhysics {
    /// Lifetime range in game ticks [min, max] (20 ticks = 1 second)
    pub lifetime: Option<[i32; 2]>,
    /// Gravity value (negative = rises, positive = falls)
    pub gravity: Option<f32>,
    /// Initial size (quad size) when explicitly set in the constructor.
    ///
    /// Note: Most sprite particles derive their starting `quadSize` from the
    /// `SingleQuadParticle` constructor's random formula; in those cases this
    /// will be `None` and `scale` should be used instead.
    pub size: Option<f32>,
    /// Scale multiplier applied via `Particle.scale(...)` or constructor scale params.
    ///
    /// This is a multiplier applied on top of the base `quadSize` (which is often randomized).
    pub scale: Option<f32>,
    /// Whether the particle has physics (collision)
    pub has_physics: Option<bool>,
    /// Initial alpha/opacity
    pub alpha: Option<f32>,
    /// Friction/drag coefficient
    pub friction: Option<f32>,
    /// Velocity multipliers applied in the particle constructor (per-axis)
    /// These operate on the particle's initial (xd, yd, zd) values.
    pub velocity_multiplier: Option<[f32; 3]>,
    /// Constant velocity added in the particle constructor (per-axis)
    pub velocity_add: Option<[f32; 3]>,
    /// Random velocity added in the particle constructor (per-axis)
    /// Interpreted as `(rand(-0.5..0.5) * value)` per axis.
    pub velocity_jitter: Option<[f32; 3]>,
    /// Base RGB color (0..1) assigned in the particle constructor
    pub color: Option<[f32; 3]>,
    /// BaseAshSmokeParticle grayscale color scale (random.nextFloat() * color_scale).
    pub color_scale: Option<f32>,
    /// BaseAshSmokeParticle base lifetime parameter (used in its lifetime formula).
    pub lifetime_base: Option<i32>,
    /// If true, animation frames map to lifetime/age (SpriteSet.get(age, lifetime)).
    pub lifetime_animation: Option<bool>,
    /// High-level behavior identifier (e.g., "particle", "rising", "ash_smoke", "flame").
    pub behavior: Option<String>,
}

/// All extracted physics for a Minecraft version
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExtractedPhysicsData {
    /// Schema version for cache compatibility
    #[serde(default)]
    pub schema_version: u32,
    pub version: String,
    pub particles: HashMap<String, ExtractedParticlePhysics>,
}

/// Parse vanilla Minecraft version from potentially modded version string
///
/// Examples:
/// - "1.21.4" -> "1.21.4"
/// - "1.21.4-fabric" -> "1.21.4"
/// - "1.21.4-fabric-0.16.5" -> "1.21.4"
/// - "1.21.10-0.18.1" -> "1.21.10" (Fabric format)
/// - "1.20.1-forge-47.2.0" -> "1.20.1"
fn parse_vanilla_version(version: &str) -> String {
    // Split by hyphen to separate version from loader info
    let parts: Vec<&str> = version.split('-').collect();
    let base = parts[0];

    // Check if base is already a valid vanilla version (X.Y or X.Y.Z format)
    let base_parts: Vec<&str> = base.split('.').collect();
    if base_parts.len() >= 2 && base_parts.len() <= 3 {
        // Check all parts are numeric
        let all_numeric = base_parts.iter().all(|p| p.parse::<u32>().is_ok());
        if all_numeric {
            // Minecraft versions like 1.21.10 are valid - don't try to "fix" them
            return base.to_string();
        }
    }

    // Fallback: try to extract version pattern from anywhere in the string
    let re = regex::Regex::new(r"(\d+\.\d+(?:\.\d+)?)").unwrap();
    if let Some(caps) = re.captures(version) {
        return caps.get(1).unwrap().as_str().to_string();
    }

    // Last resort: return original
    version.to_string()
}

/// Mojang version manifest structure
#[derive(Debug, Deserialize)]
struct VersionManifest {
    versions: Vec<VersionEntry>,
}

#[derive(Debug, Deserialize)]
struct VersionEntry {
    id: String,
    url: String,
}

/// Version-specific JSON structure (partial)
#[derive(Debug, Deserialize)]
struct VersionJson {
    downloads: VersionDownloads,
}

#[derive(Debug, Deserialize)]
struct VersionDownloads {
    client_mappings: Option<DownloadInfo>,
}

#[derive(Debug, Deserialize)]
struct DownloadInfo {
    url: String,
    #[allow(dead_code)]
    sha1: String,
}

/// Get the cache directory for particle physics extraction
fn get_physics_cache_dir() -> Result<PathBuf> {
    let cache_dir = dirs::cache_dir()
        .ok_or_else(|| anyhow!("Could not find cache directory"))?
        .join("weaverbird")
        .join("particle_physics");

    fs::create_dir_all(&cache_dir).context("Failed to create particle physics cache directory")?;

    Ok(cache_dir)
}

/// Get the cache file path for extracted physics data
fn get_physics_cache_file(version: &str) -> Result<PathBuf> {
    let cache_dir = get_physics_cache_dir()?;
    Ok(cache_dir.join(format!("{}.json", version)))
}

/// Check if physics data is cached for a version
pub fn is_physics_data_cached(version: &str) -> Result<bool> {
    // Treat older-schema cache files as "not cached" so callers trigger re-extraction.
    Ok(load_cached_physics_data(version)?.is_some())
}

/// Load cached physics data
pub fn load_cached_physics_data(version: &str) -> Result<Option<ExtractedPhysicsData>> {
    let cache_file = get_physics_cache_file(version)?;

    if !cache_file.exists() {
        return Ok(None);
    }

    let content = fs::read_to_string(&cache_file).context("Failed to read physics cache file")?;
    let data: ExtractedPhysicsData =
        serde_json::from_str(&content).context("Failed to parse physics cache file")?;

    // If the cache is from an older schema, force re-extraction to populate new fields.
    const CURRENT_SCHEMA_VERSION: u32 = 3;
    if data.schema_version < CURRENT_SCHEMA_VERSION {
        println!(
            "[particle_physics] Cached physics schema {} is older than {}, re-extracting...",
            data.schema_version, CURRENT_SCHEMA_VERSION
        );
        return Ok(None);
    }

    Ok(Some(data))
}

/// Save physics data to cache
fn save_physics_data_to_cache(data: &ExtractedPhysicsData) -> Result<()> {
    let cache_file = get_physics_cache_file(&data.version)?;
    let content = serde_json::to_string_pretty(data).context("Failed to serialize physics data")?;
    fs::write(&cache_file, content).context("Failed to write physics cache file")?;

    println!(
        "[particle_physics] Cached physics data for version {} ({} particles)",
        data.version,
        data.particles.len()
    );

    Ok(())
}

// NOTE: Deprecated - particle physics is now generated as part of the combined
// TypeScript file in particle_typescript_gen.rs instead of individually.

/// Download Mojang mappings for a version
pub async fn download_mojang_mappings(version: &str) -> Result<PathBuf> {
    // Parse vanilla version from potentially modded version string
    let vanilla_version = parse_vanilla_version(version);

    let cache_dir = get_physics_cache_dir()?;
    // Cache with original version name but download using vanilla version
    let mappings_file = cache_dir.join(format!("{}-mappings.txt", version));

    // Check if already downloaded
    if mappings_file.exists() {
        println!(
            "[particle_physics] Using cached mappings for {}",
            version
        );
        return Ok(mappings_file);
    }

    println!(
        "[particle_physics] Downloading Mojang mappings for {} (vanilla: {})...",
        version, vanilla_version
    );

    // Step 1: Fetch version manifest
    let manifest_url = "https://piston-meta.mojang.com/mc/game/version_manifest_v2.json";
    let manifest_response = reqwest::get(manifest_url)
        .await
        .context("Failed to fetch version manifest")?;
    let manifest: VersionManifest = manifest_response
        .json()
        .await
        .context("Failed to parse version manifest")?;

    // Step 2: Find the version URL using vanilla version
    let version_entry = manifest
        .versions
        .iter()
        .find(|v| v.id == vanilla_version)
        .ok_or_else(|| anyhow!("Version {} (vanilla: {}) not found in manifest", version, vanilla_version))?;

    // Step 3: Fetch version JSON
    let version_response = reqwest::get(&version_entry.url)
        .await
        .context("Failed to fetch version JSON")?;
    let version_json: VersionJson = version_response
        .json()
        .await
        .context("Failed to parse version JSON")?;

    // Step 4: Get mappings URL
    let mappings_info = version_json
        .downloads
        .client_mappings
        .ok_or_else(|| anyhow!("No client mappings available for version {}", version))?;

    // Step 5: Download mappings
    let mappings_response = reqwest::get(&mappings_info.url)
        .await
        .context("Failed to download mappings")?;
    let mappings_content = mappings_response
        .bytes()
        .await
        .context("Failed to read mappings content")?;

    // Save to cache
    fs::write(&mappings_file, &mappings_content).context("Failed to save mappings file")?;

    println!(
        "[particle_physics] Downloaded mappings for {} ({} bytes)",
        version,
        mappings_content.len()
    );

    Ok(mappings_file)
}

/// Field mappings for the Particle base class
/// Maps deobfuscated field name to obfuscated name
#[derive(Debug, Default, Clone)]
pub struct ParticleFieldMappings {
    pub lifetime: Option<String>,
    pub gravity: Option<String>,
    pub has_physics: Option<String>,
    pub friction: Option<String>,
    // SingleQuadParticle fields (used by most sprite-based particles)
    pub quad_size: Option<String>,
    pub alpha: Option<String>,
    pub r_col: Option<String>,
    pub g_col: Option<String>,
    pub b_col: Option<String>,
    pub xd: Option<String>,
    pub yd: Option<String>,
    pub zd: Option<String>,
}

/// Parse Mojang mappings file to get class and field mappings
fn parse_mappings(mappings_path: &Path) -> Result<(HashMap<String, String>, ParticleFieldMappings)> {
    let file = fs::File::open(mappings_path).context("Failed to open mappings file")?;
    let reader = BufReader::new(file);

    let mut class_mappings = HashMap::new();
    let mut particle_fields = ParticleFieldMappings::default();
    let mut in_particle_class = false;
    let mut in_single_quad_particle_class = false;

    for line in reader.lines() {
        let line = line.context("Failed to read line")?;

        // Class mappings look like:
        // net.minecraft.client.particle.FlameParticle -> abc:
        if line.ends_with(':') && !line.starts_with(' ') {
            let parts: Vec<&str> = line.trim_end_matches(':').split(" -> ").collect();
            if parts.len() == 2 {
                let deobfuscated = parts[0];
                let obfuscated = parts[1].to_string();
                class_mappings.insert(obfuscated, deobfuscated.to_string());
                // Check if this is the base Particle class
                in_particle_class = deobfuscated == "net.minecraft.client.particle.Particle";
                in_single_quad_particle_class =
                    deobfuscated == "net.minecraft.client.particle.SingleQuadParticle";
            }
        }
        // Field mappings look like (indented with 4 spaces):
        //     int lifetime -> t
        //     float gravity -> u
        else if line.starts_with("    ") && !line.contains('(') && (in_particle_class || in_single_quad_particle_class) {
            // This is a field mapping (methods have parentheses)
            let trimmed = line.trim();
            let parts: Vec<&str> = trimmed.split(" -> ").collect();
            if parts.len() == 2 {
                // Format: "type fieldName -> obfName"
                let type_and_name = parts[0];
                let obf_name = parts[1].to_string();

                // Extract field name (last word before ->)
                let words: Vec<&str> = type_and_name.split_whitespace().collect();
                if words.len() >= 2 {
                    let field_name = words[words.len() - 1];

                    if in_particle_class {
                        // Base Particle fields
                        match field_name {
                            "lifetime" => particle_fields.lifetime = Some(obf_name),
                            "gravity" => particle_fields.gravity = Some(obf_name),
                            "hasPhysics" => particle_fields.has_physics = Some(obf_name),
                            "friction" => particle_fields.friction = Some(obf_name),
                            "xd" => particle_fields.xd = Some(obf_name),
                            "yd" => particle_fields.yd = Some(obf_name),
                            "zd" => particle_fields.zd = Some(obf_name),
                            _ => {}
                        }
                    } else if in_single_quad_particle_class {
                        // SingleQuadParticle fields (rendering)
                        match field_name {
                            "quadSize" => particle_fields.quad_size = Some(obf_name),
                            "rCol" => particle_fields.r_col = Some(obf_name),
                            "gCol" => particle_fields.g_col = Some(obf_name),
                            "bCol" => particle_fields.b_col = Some(obf_name),
                            "alpha" => particle_fields.alpha = Some(obf_name),
                            _ => {}
                        }
                    }
                }
            }
        }
    }

    println!(
        "[particle_physics] Parsed {} class mappings",
        class_mappings.len()
    );
    println!(
        "[particle_physics] Particle field mappings: lifetime={:?}, gravity={:?}, hasPhysics={:?}, friction={:?}, xd={:?}, yd={:?}, zd={:?}, quadSize={:?}, rCol={:?}, gCol={:?}, bCol={:?}, alpha={:?}",
        particle_fields.lifetime,
        particle_fields.gravity,
        particle_fields.has_physics,
        particle_fields.friction,
        particle_fields.xd,
        particle_fields.yd,
        particle_fields.zd,
        particle_fields.quad_size
        , particle_fields.r_col
        , particle_fields.g_col
        , particle_fields.b_col
        , particle_fields.alpha
    );

    Ok((class_mappings, particle_fields))
}

/// Known particle classes and their corresponding particle type IDs
/// This maps the deobfuscated class name to the particle type
fn get_particle_class_mappings() -> HashMap<&'static str, &'static str> {
    let mut map = HashMap::new();

    // Base classes - extract physics from these as they're inherited by many particles
    map.insert("net.minecraft.client.particle.Particle", "__base_particle");
    map.insert("net.minecraft.client.particle.RisingParticle", "__base_rising");
    map.insert("net.minecraft.client.particle.SimpleAnimatedParticle", "__base_simple_animated");
    map.insert("net.minecraft.client.particle.BaseAshSmokeParticle", "__base_ash_smoke");
    map.insert("net.minecraft.client.particle.TextureSheetParticle", "__base_texture_sheet");

    // Fire & Flame
    map.insert("net.minecraft.client.particle.FlameParticle", "flame");
    map.insert("net.minecraft.client.particle.SoulParticle", "soul_fire_flame");
    map.insert("net.minecraft.client.particle.LavaParticle", "lava");
    map.insert("net.minecraft.client.particle.CandleFlameParticle", "candle_flame");

    // Smoke
    map.insert("net.minecraft.client.particle.SmokeParticle", "smoke");
    map.insert("net.minecraft.client.particle.LargeSmokeParticle", "large_smoke");
    map.insert("net.minecraft.client.particle.CampfireSmokeParticle", "campfire_cosy_smoke");
    map.insert("net.minecraft.client.particle.WhiteAshParticle", "white_ash");

    // Effects
    map.insert("net.minecraft.client.particle.SpellParticle", "effect");
    map.insert("net.minecraft.client.particle.CritParticle", "crit");
    map.insert("net.minecraft.client.particle.HeartParticle", "heart");
    map.insert("net.minecraft.client.particle.NoteParticle", "note");
    map.insert("net.minecraft.client.particle.DamageIndicatorParticle", "damage_indicator");
    map.insert("net.minecraft.client.particle.EnchantmentTableParticle", "enchant");
    map.insert("net.minecraft.client.particle.TotemParticle", "totem_of_undying");
    map.insert("net.minecraft.client.particle.HugeExplosionParticle", "explosion");
    map.insert("net.minecraft.client.particle.HugeExplosionSeedParticle", "explosion_emitter");

    // Portal
    map.insert("net.minecraft.client.particle.PortalParticle", "portal");
    map.insert("net.minecraft.client.particle.ReversePortalParticle", "reverse_portal");

    // End
    map.insert("net.minecraft.client.particle.EndRodParticle", "end_rod");
    map.insert("net.minecraft.client.particle.DragonBreathParticle", "dragon_breath");

    // Drip
    map.insert("net.minecraft.client.particle.DripParticle", "dripping_water");

    // Bubbles
    map.insert("net.minecraft.client.particle.BubbleParticle", "bubble");
    map.insert("net.minecraft.client.particle.BubblePopParticle", "bubble_pop");
    map.insert("net.minecraft.client.particle.BubbleColumnUpParticle", "bubble_column_up");
    map.insert("net.minecraft.client.particle.CurrentDownParticle", "current_down");

    // Dust/Particles
    map.insert("net.minecraft.client.particle.DustParticle", "dust");
    map.insert("net.minecraft.client.particle.DustColorTransitionParticle", "dust_color_transition");
    map.insert("net.minecraft.client.particle.DustPlumeParticle", "dust_plume");
    map.insert("net.minecraft.client.particle.FallingDustParticle", "falling_dust");

    // Water
    map.insert("net.minecraft.client.particle.SplashParticle", "splash");
    map.insert("net.minecraft.client.particle.SuspendedParticle", "underwater");
    map.insert("net.minecraft.client.particle.SnowflakeParticle", "snowflake");
    map.insert("net.minecraft.client.particle.RainParticle", "rain");
    map.insert("net.minecraft.client.particle.WaterDropParticle", "falling_water");

    // Misc
    map.insert("net.minecraft.client.particle.SquidInkParticle", "squid_ink");
    map.insert("net.minecraft.client.particle.GlowParticle", "glow");
    map.insert("net.minecraft.client.particle.WaxOffParticle", "wax_off");
    map.insert("net.minecraft.client.particle.WaxOnParticle", "wax_on");
    map.insert("net.minecraft.client.particle.ScrapeParticle", "scrape");
    map.insert("net.minecraft.client.particle.ElectricSparkParticle", "electric_spark");
    map.insert("net.minecraft.client.particle.VibrationSignalParticle", "vibration");
    map.insert("net.minecraft.client.particle.ShriekParticle", "shriek");
    map.insert("net.minecraft.client.particle.SculkChargeParticle", "sculk_charge");
    map.insert("net.minecraft.client.particle.SculkChargePopParticle", "sculk_charge_pop");
    map.insert("net.minecraft.client.particle.SonicBoomParticle", "sonic_boom");
    map.insert("net.minecraft.client.particle.BlockMarker", "block_marker");
    map.insert("net.minecraft.client.particle.BreakingItemParticle", "item");
    map.insert("net.minecraft.client.particle.TerrainParticle", "block");

    // Sculk
    map.insert("net.minecraft.client.particle.SculkSoulParticle", "sculk_soul");

    // Cherry
    map.insert("net.minecraft.client.particle.CherryParticle", "cherry_leaves");

    // Trail
    map.insert("net.minecraft.client.particle.TrailParticle", "trail");
    map.insert("net.minecraft.client.particle.OminousSpawningParticle", "ominous_spawning");

    // Provider classes - these contain the actual physics values for particles that inherit
    // The Provider's createParticle method instantiates the particle with specific values
    map.insert("net.minecraft.client.particle.FlameParticle$Provider", "__provider_flame");
    map.insert("net.minecraft.client.particle.FlameParticle$SmallFlameProvider", "__provider_small_flame");
    map.insert("net.minecraft.client.particle.SmokeParticle$Provider", "__provider_smoke");
    map.insert("net.minecraft.client.particle.LargeSmokeParticle$Provider", "__provider_large_smoke");
    map.insert("net.minecraft.client.particle.SoulParticle$Provider", "__provider_soul_fire_flame");
    map.insert("net.minecraft.client.particle.SoulParticle$EmissiveProvider", "__provider_soul_fire_flame_emissive");
    map.insert("net.minecraft.client.particle.PortalParticle$Provider", "__provider_portal");
    map.insert("net.minecraft.client.particle.DustParticle$Provider", "__provider_dust");
    map.insert("net.minecraft.client.particle.CampfireSmokeParticle$CosyProvider", "__provider_campfire_cosy");
    map.insert("net.minecraft.client.particle.CampfireSmokeParticle$SignalProvider", "__provider_campfire_signal");

    map
}

/// Default physics values extracted from the base Particle class
/// These are the values used when a particle doesn't explicitly set its own
fn get_base_particle_defaults() -> ExtractedParticlePhysics {
    ExtractedParticlePhysics {
        // Default lifetime: (int)(4.0f / (random * 0.9f + 0.1f)) = ~4-40 ticks
        lifetime: Some([4, 40]),
        // Default gravity: 0 (no gravity)
        gravity: Some(0.0),
        // Default friction: 0.98
        friction: Some(0.98),
        // Default hasPhysics: true
        has_physics: Some(true),
        // Size depends on particle type
        size: None,
        scale: None,
        alpha: None,
        velocity_multiplier: None,
        velocity_add: None,
        velocity_jitter: None,
        color: None,
        color_scale: None,
        lifetime_base: None,
        lifetime_animation: None,
        behavior: Some("particle".to_string()),
    }
}

/// Default physics for RisingParticle base class
fn get_rising_particle_defaults() -> ExtractedParticlePhysics {
    ExtractedParticlePhysics {
        // RisingParticle: (int)(8.0 / (Math.random() * 0.8 + 0.2)) + 4 = ~12-44 ticks
        lifetime: Some([12, 44]),
        // RisingParticle doesn't set gravity, inherits 0 from Particle
        gravity: Some(0.0),
        // RisingParticle sets friction to 0.96
        friction: Some(0.96),
        has_physics: Some(true),
        size: None,
        scale: None,
        alpha: None,
        velocity_multiplier: None,
        velocity_add: None,
        velocity_jitter: None,
        color: None,
        color_scale: None,
        lifetime_base: None,
        lifetime_animation: None,
        behavior: Some("rising".to_string()),
    }
}

/// Default physics for BaseAshSmokeParticle base class
///
/// BaseAshSmokeParticle sets friction and drives sprite animation by age.
/// Other behavior-specific parameters (gravity, base lifetime, color scale, scale)
/// are supplied via the derived class super() call and provider.
fn get_ash_smoke_particle_defaults() -> ExtractedParticlePhysics {
    ExtractedParticlePhysics {
        lifetime: None,
        gravity: None,
        size: None,
        scale: None,
        has_physics: None,
        alpha: None,
        friction: Some(0.96),
        velocity_multiplier: None,
        velocity_add: None,
        velocity_jitter: None,
        color: None,
        color_scale: None,
        lifetime_base: None,
        lifetime_animation: Some(true),
        behavior: Some("ash_smoke".to_string()),
    }
}

/// Map Provider types to their corresponding particle type
fn get_provider_to_particle_map() -> HashMap<&'static str, &'static str> {
    let mut map = HashMap::new();
    map.insert("__provider_flame", "flame");
    map.insert("__provider_small_flame", "small_flame");
    map.insert("__provider_smoke", "smoke");
    map.insert("__provider_large_smoke", "large_smoke");
    map.insert("__provider_soul_fire_flame", "soul_fire_flame");
    map.insert("__provider_soul_fire_flame_emissive", "soul_fire_flame");
    map.insert("__provider_portal", "portal");
    map.insert("__provider_dust", "dust");
    map.insert("__provider_campfire_cosy", "campfire_cosy_smoke");
    map.insert("__provider_campfire_signal", "campfire_signal_smoke");
    map
}

/// Map of particle types to their base class particle type
/// Used to inherit physics from parent classes when a particle doesn't define its own
fn get_particle_inheritance() -> HashMap<&'static str, &'static str> {
    let mut map = HashMap::new();

    // Particles that extend RisingParticle (inherits friction=0.96, lifetime=12-44)
    map.insert("flame", "__base_rising");
    map.insert("soul_fire_flame", "__base_rising");
    map.insert("candle_flame", "__base_rising");
    map.insert("small_flame", "__base_rising");

    // Particles that extend BaseAshSmokeParticle (passes values via super()).
    // SmokeParticle calls: super(..., 0.3f, 8, -0.1f, true) where `0.3f` is a grayscale color scale,
    // and lifetime is computed from `baseLifetime` and a random divisor (not a constant 8 ticks).
    map.insert("smoke", "__base_ash_smoke");
    map.insert("large_smoke", "__base_ash_smoke");
    map.insert("white_ash", "__base_ash_smoke");

    // Particles that extend SimpleAnimatedParticle
    map.insert("campfire_cosy_smoke", "__base_simple_animated");
    map.insert("campfire_signal_smoke", "__base_simple_animated");
    map.insert("portal", "__base_simple_animated");
    map.insert("reverse_portal", "__base_simple_animated");
    map.insert("end_rod", "__base_simple_animated");
    map.insert("enchant", "__base_simple_animated");
    map.insert("dragon_breath", "__base_simple_animated");
    map.insert("sculk_soul", "__base_simple_animated");
    map.insert("glow", "__base_simple_animated");
    map.insert("totem_of_undying", "__base_simple_animated");

    // Particles that extend TextureSheetParticle directly (base Particle defaults)
    map.insert("heart", "__base_particle");
    map.insert("note", "__base_particle");
    map.insert("crit", "__base_particle");
    map.insert("damage_indicator", "__base_particle");
    map.insert("effect", "__base_particle");
    map.insert("dust", "__base_particle");
    map.insert("dust_color_transition", "__base_particle");
    map.insert("dust_plume", "__base_particle");
    map.insert("falling_dust", "__base_particle");
    map.insert("splash", "__base_particle");
    map.insert("bubble", "__base_particle");
    map.insert("bubble_pop", "__base_particle");
    map.insert("bubble_column_up", "__base_particle");
    map.insert("current_down", "__base_particle");
    map.insert("underwater", "__base_particle");
    map.insert("snowflake", "__base_particle");
    map.insert("rain", "__base_particle");
    map.insert("dripping_water", "__base_particle");
    map.insert("lava", "__base_particle");
    map.insert("squid_ink", "__base_particle");
    map.insert("wax_off", "__base_particle");
    map.insert("wax_on", "__base_particle");
    map.insert("scrape", "__base_particle");
    map.insert("electric_spark", "__base_particle");
    map.insert("cherry_leaves", "__base_particle");
    map.insert("explosion", "__base_particle");
    map.insert("explosion_emitter", "__base_particle");
    map.insert("block", "__base_particle");
    map.insert("item", "__base_particle");
    map.insert("falling_water", "__base_particle");

    map
}

/// Check if CFR decompiler is available (needed for block particle extraction)
fn find_cfr_jar() -> Option<PathBuf> {
    let locations = vec![
        PathBuf::from("resources/cfr.jar"),
        dirs::cache_dir()
            .map(|d| d.join("weaverbird").join("tools").join("cfr.jar"))
            .unwrap_or_default(),
    ];

    for loc in locations {
        if loc.exists() {
            return Some(loc);
        }
    }

    None
}

/// Download CFR decompiler if not present (needed for block particle extraction)
pub async fn ensure_cfr_available() -> Result<PathBuf> {
    if let Some(path) = find_cfr_jar() {
        return Ok(path);
    }

    let tools_dir = dirs::cache_dir()
        .ok_or_else(|| anyhow!("Could not find cache directory"))?
        .join("weaverbird")
        .join("tools");

    fs::create_dir_all(&tools_dir).context("Failed to create tools directory")?;

    let cfr_path = tools_dir.join("cfr.jar");

    println!("[particle_physics] Downloading CFR decompiler...");

    let cfr_url = "https://github.com/leibnitz27/cfr/releases/download/0.152/cfr-0.152.jar";
    let response = reqwest::get(cfr_url)
        .await
        .context("Failed to download CFR")?;
    let bytes = response.bytes().await.context("Failed to read CFR bytes")?;

    fs::write(&cfr_path, &bytes).context("Failed to save CFR")?;

    println!(
        "[particle_physics] Downloaded CFR decompiler ({} bytes)",
        bytes.len()
    );

    Ok(cfr_path)
}

/// Extract physics data from a class file using bytecode parsing (FAST - no CFR needed!)
/// Performance: ~10-50ms per class vs 1-2 seconds with CFR
fn extract_physics_from_bytecode(
    jar_path: &Path,
    obfuscated_class_name: &str,
    field_mappings: &ParticleFieldMappings,
) -> Result<ExtractedParticlePhysics> {
    // Convert class name to .class file path in JAR (e.g., "net/minecraft/Foo" -> "net/minecraft/Foo.class")
    let class_path = format!("{}.class", obfuscated_class_name.replace('.', "/"));

    // Read the class file bytes from the JAR
    let class_bytes = extract_zip_entry(jar_path.to_str().unwrap(), &class_path)
        .with_context(|| format!("Failed to extract class: {}", class_path))?;

    // Parse bytecode to extract field assignments
    let extraction = extract_bytecode_info(&class_bytes)
        .with_context(|| format!("Failed to parse bytecode for: {}", obfuscated_class_name))?;

    let mut physics = ExtractedParticlePhysics::default();

    // Map obfuscated field names to physics values
    for assignment in &extraction.field_assignments {
        let field_name = &assignment.field_name;
        let value = &assignment.value;

        // Match against known physics fields
        if Some(field_name) == field_mappings.gravity.as_ref() {
            physics.gravity = value.as_f32();
        } else if Some(field_name) == field_mappings.has_physics.as_ref() {
            physics.has_physics = value.as_i32().map(|v| v != 0);
        } else if Some(field_name) == field_mappings.friction.as_ref() {
            physics.friction = value.as_f32();
        } else if Some(field_name) == field_mappings.quad_size.as_ref() {
            physics.size = value.as_f32();
        } else if Some(field_name) == field_mappings.alpha.as_ref() {
            physics.alpha = value.as_f32();
        } else if Some(field_name) == field_mappings.lifetime.as_ref() {
            // Lifetime might be a base value; we'll handle range separately
            if let Some(base) = value.as_i32() {
                physics.lifetime = Some([base, base]);
            }
        }
    }

    Ok(physics)
}

/// Decompile a specific class from the JAR
pub async fn extract_particle_physics(
    jar_path: &Path,
    version: &str,
) -> Result<ExtractedPhysicsData> {
    // Check cache first
    if let Some(cached) = load_cached_physics_data(version)? {
        println!(
            "[particle_physics] Using cached physics data for {}",
            version
        );
        return Ok(cached);
    }

    println!(
        "[particle_physics] Extracting particle physics for {}...",
        version
    );

    // Download mappings
    let mappings_path = download_mojang_mappings(version).await?;
    let (class_mappings, field_mappings) = parse_mappings(&mappings_path)?;

    let particle_classes = get_particle_class_mappings();
    let provider_map = get_provider_to_particle_map();

    println!("[particle_physics] Extracting physics from {} particle classes using bytecode parsing...", particle_classes.len());
    let start_time = std::time::Instant::now();

    // Process all particles in parallel using rayon
    use rayon::prelude::*;
    use std::sync::atomic::{AtomicUsize, Ordering};
    let processed = AtomicUsize::new(0);
    let total = particle_classes.len();

    let extracted_particles: HashMap<String, ExtractedParticlePhysics> = particle_classes
        .par_iter()
        .filter_map(|(class_name, particle_type)| {
            let count = processed.fetch_add(1, Ordering::Relaxed) + 1;
            if count % 10 == 0 || count == total {
                println!("[particle_physics] Progress: {}/{} particles processed", count, total);
            }
            // Find the obfuscated name
            let obfuscated_name = class_mappings
                .iter()
                .find(|(_, v)| *v == *class_name)
                .map(|(k, _)| k.as_str())?;

            // Use bytecode parsing (FAST! ~10-50ms per class)
            // If it fails, just skip this particle (better than crashing)
            let physics = match extract_physics_from_bytecode(jar_path, obfuscated_name, &field_mappings) {
                Ok(p) => p,
                Err(e) => {
                    // Log error but don't fail entire extraction
                    if count == 1 {
                        eprintln!("[particle_physics] Warning: Bytecode parsing error (showing first only): {}", e);
                    }
                    return None;
                }
            };

            // Only include if we found any physics values
            if physics.lifetime.is_some()
                || physics.gravity.is_some()
                || physics.size.is_some()
                || physics.has_physics.is_some()
                || physics.friction.is_some()
            {
                // For provider classes, map to the actual particle type
                let target_type = if particle_type.starts_with("__provider_") {
                    provider_map.get(particle_type).unwrap_or(particle_type).to_string()
                } else {
                    particle_type.to_string()
                };

                Some((target_type, physics))
            } else {
                None
            }
        })
        .collect();

    let elapsed = start_time.elapsed();
    println!(
        "[particle_physics] âœ“ Extracted physics for {} particles in {:.2}s",
        extracted_particles.len(),
        elapsed.as_secs_f32()
    );

    // Apply inheritance: fill in missing physics from parent classes
    let inheritance_map = get_particle_inheritance();
    let base_defaults = get_base_particle_defaults();
    let rising_defaults = get_rising_particle_defaults();
    let ash_smoke_defaults = get_ash_smoke_particle_defaults();
    let mut final_particles = extracted_particles.clone();

    for (particle_type, parent_type) in inheritance_map.iter() {
        // Skip base classes themselves
        if particle_type.starts_with("__base_") {
            continue;
        }

        // Get current physics for this particle (or empty)
        let current = final_particles.get(*particle_type).cloned().unwrap_or_default();

        // Get parent physics - use hardcoded defaults for base classes if not extracted
        let parent_physics = if *parent_type == "__base_particle" {
            base_defaults.clone()
        } else if *parent_type == "__base_rising" {
            rising_defaults.clone()
        } else if *parent_type == "__base_ash_smoke" {
            ash_smoke_defaults.clone()
        } else {
            extracted_particles.get(*parent_type).cloned().unwrap_or(base_defaults.clone())
        };

        // Merge: use current values where present, fall back to parent values
        let merged = ExtractedParticlePhysics {
            lifetime: current.lifetime.or(parent_physics.lifetime),
            gravity: current.gravity.or(parent_physics.gravity),
            size: current.size.or(parent_physics.size),
            scale: current.scale.or(parent_physics.scale),
            has_physics: current.has_physics.or(parent_physics.has_physics),
            alpha: current.alpha.or(parent_physics.alpha),
            friction: current.friction.or(parent_physics.friction),
            velocity_multiplier: current.velocity_multiplier.or(parent_physics.velocity_multiplier),
            velocity_add: current.velocity_add.or(parent_physics.velocity_add),
            velocity_jitter: current.velocity_jitter.or(parent_physics.velocity_jitter),
            color: current.color.or(parent_physics.color),
            color_scale: current.color_scale.or(parent_physics.color_scale),
            lifetime_base: current.lifetime_base.or(parent_physics.lifetime_base),
            lifetime_animation: current.lifetime_animation.or(parent_physics.lifetime_animation),
            behavior: current.behavior.or(parent_physics.behavior),
        };

        // Only add if we have some useful values
        if merged.lifetime.is_some()
            || merged.gravity.is_some()
            || merged.size.is_some()
            || merged.scale.is_some()
            || merged.has_physics.is_some()
            || merged.alpha.is_some()
            || merged.friction.is_some()
            || merged.velocity_multiplier.is_some()
            || merged.velocity_add.is_some()
            || merged.velocity_jitter.is_some()
            || merged.color.is_some()
            || merged.color_scale.is_some()
            || merged.lifetime_base.is_some()
            || merged.lifetime_animation.is_some()
            || merged.behavior.is_some()
        {
            println!(
                "[particle_physics] {} inherits from {}: {:?}",
                particle_type, parent_type, merged
            );
            final_particles.insert(particle_type.to_string(), merged);
        }
    }

    // Post-process behavior-specific derived values.
    // BaseAshSmokeParticle lifetime is computed from `lifetime_base` and `scale`:
    // lifetime = (int)(baseLifetime / (rand * 0.8 + 0.2) * scale)
    // Range is [baseLifetime*scale, baseLifetime*scale*5] (clamped to >= 1).
    for physics in final_particles.values_mut() {
        if physics.lifetime.is_none() {
            if physics.behavior.as_deref() == Some("ash_smoke") {
                if let Some(base) = physics.lifetime_base {
                    let scale = physics.scale.unwrap_or(1.0);
                    let min = ((base as f32) * scale).floor() as i32;
                    let max = ((base as f32) * scale * 5.0).floor() as i32;
                    physics.lifetime = Some([min.max(1), max.max(1)]);
                }
            }
        }
    }

    // Remove base class entries (they're internal, not real particle types)
    final_particles.retain(|k, _| !k.starts_with("__base_") && !k.starts_with("__provider_"));

    let data = ExtractedPhysicsData {
        schema_version: 3,
        version: version.to_string(),
        particles: final_particles,
    };

    // Cache the results
    save_physics_data_to_cache(&data)?;

    Ok(data)
}

/// Get particle physics, preferring extracted data over hardcoded defaults
pub async fn get_particle_physics_for_version(
    jar_path: &Path,
    version: &str,
) -> Result<ExtractedPhysicsData> {
    // Check cache first
    if let Some(cached) = load_cached_physics_data(version)? {
        return Ok(cached);
    }

    // Try to extract
    extract_particle_physics(jar_path, version).await
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Create field mappings with readable names (for testing deobfuscated code)
    fn readable_field_mappings() -> ParticleFieldMappings {
        ParticleFieldMappings {
            lifetime: Some("lifetime".to_string()),
            gravity: Some("gravity".to_string()),
            has_physics: Some("hasPhysics".to_string()),
            friction: Some("friction".to_string()),
            quad_size: Some("quadSize".to_string()),
            alpha: Some("alpha".to_string()),
            r_col: Some("rCol".to_string()),
            g_col: Some("gCol".to_string()),
            b_col: Some("bCol".to_string()),
            xd: Some("xd".to_string()),
            yd: Some("yd".to_string()),
            zd: Some("zd".to_string()),
        }
    }

    /// Create field mappings with obfuscated names (for testing obfuscated code)
    fn obfuscated_field_mappings() -> ParticleFieldMappings {
        ParticleFieldMappings {
            lifetime: Some("t".to_string()),
            gravity: Some("u".to_string()),
            has_physics: Some("n".to_string()),
            friction: Some("B".to_string()),
            quad_size: Some("C".to_string()),
            alpha: Some("g".to_string()),
            r_col: Some("d".to_string()),
            g_col: Some("e".to_string()),
            b_col: Some("f".to_string()),
            xd: Some("o".to_string()),
            yd: Some("p".to_string()),
            zd: Some("q".to_string()),
        }
    }

    #[test]
    fn test_extract_physics_from_readable_source() {
        // Test with readable (deobfuscated) field names
        let source = r#"
            public FlameParticle(Level level, double x, double y, double z) {
                super(level, x, y, z);
                this.lifetime = 8 + this.random.nextInt(4);
                this.gravity = -0.06f;
                this.quadSize = 0.1f;
                this.hasPhysics = false;
            }
        "#;

        let physics = extract_physics_from_source(source, &readable_field_mappings());
        assert_eq!(physics.lifetime, Some([8, 12]));
        assert_eq!(physics.gravity, Some(-0.06));
        assert_eq!(physics.size, Some(0.1));
        assert_eq!(physics.has_physics, Some(false));
    }

    #[test]
    fn test_extract_physics_from_obfuscated_source() {
        // Test with obfuscated field names (as CFR actually outputs)
        let source = r#"
            public gca(gcm gcm2, double d, double d2, double d3) {
                super(gcm2, d, d2, d3);
                this.t = 8 + this.o.a(4);
                this.u = -0.06f;
                this.C = 0.1f;
                this.n = false;
            }
        "#;

        let physics = extract_physics_from_source(source, &obfuscated_field_mappings());
        assert_eq!(physics.lifetime, Some([8, 12]));
        assert_eq!(physics.gravity, Some(-0.06));
        assert_eq!(physics.size, Some(0.1));
        assert_eq!(physics.has_physics, Some(false));
    }

    #[test]
    fn test_particle_class_mappings() {
        let mappings = get_particle_class_mappings();
        assert!(mappings.contains_key("net.minecraft.client.particle.FlameParticle"));
        assert_eq!(
            mappings.get("net.minecraft.client.particle.FlameParticle"),
            Some(&"flame")
        );
    }

    #[test]
    fn test_parse_vanilla_version() {
        // Clean vanilla versions
        assert_eq!(parse_vanilla_version("1.21.4"), "1.21.4");
        assert_eq!(parse_vanilla_version("1.20.1"), "1.20.1");
        assert_eq!(parse_vanilla_version("1.21"), "1.21");
        assert_eq!(parse_vanilla_version("1.21.10"), "1.21.10");
        assert_eq!(parse_vanilla_version("1.21.11"), "1.21.11");

        // Fabric modded versions
        assert_eq!(parse_vanilla_version("1.21.4-fabric"), "1.21.4");
        assert_eq!(parse_vanilla_version("1.21.4-fabric-0.16.5"), "1.21.4");
        assert_eq!(parse_vanilla_version("1.21.10-0.18.1"), "1.21.10");

        // Forge modded versions
        assert_eq!(parse_vanilla_version("1.20.1-forge-47.2.0"), "1.20.1");
    }
}

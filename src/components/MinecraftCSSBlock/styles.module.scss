/**
 * CSS Isometric Minecraft Block - Dynamic Element Rendering
 *
 * Renders block model elements as isometric 3D using CSS transforms.
 * Supports multiple elements for complex blocks like fences, stairs, etc.
 *
 * Each face receives CSS custom properties for:
 * - Position (--face-x, --face-y)
 * - Size (--face-width, --face-height)
 * - UV coordinates (--uv-x, --uv-y, --uv-width, --uv-height)
 * - Brightness for shading (--face-brightness)
 */

.blockContainer {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

.fallbackTexture {
    width: 70%;
    height: 70%;
    object-fit: contain;
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
}

.loading {
    width: 50%;
    height: 50%;
    border-radius: var(--radius-sm);
    background: linear-gradient(
        90deg,
        var(--color-bg-secondary) 25%,
        var(--color-border) 50%,
        var(--color-bg-secondary) 75%
    );
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
    0% {
        background-position: 200% 0;
    }
    100% {
        background-position: -200% 0;
    }
}

.blockScene {
    position: relative;
    width: 100%;
    height: 100%;
    // Center the isometric projection
    display: flex;
    align-items: center;
    justify-content: center;
    // Enable 3D transforms for proper face positioning
    transform-style: preserve-3d;
    // Isometric view: rotate the whole scene
    // rotateX(-30deg) tilts down to see top, rotateY(-45deg) rotates to see two sides
    transform: translateY(10%) rotateX(-30deg) rotateY(-45deg);
}

// Base face styles
.face {
    position: absolute;
    // Position from center using custom properties
    left: 50%;
    top: 50%;
    transform-origin: center center;
    overflow: hidden;
    // Slight scale up to eliminate subpixel gaps between faces
    // Using padding instead of scale to avoid blurring textures
    margin: -0.5px;
    padding: 0.5px;

    img {
        // Position and scale image for UV mapping
        position: absolute;
        // Scale image to show only the UV portion
        width: calc(100% / var(--uv-width, 1));
        height: calc(100% / var(--uv-height, 1));
        // Offset for UV coordinates
        left: calc(-100% * var(--uv-x, 0) / var(--uv-width, 1));
        top: calc(-100% * var(--uv-y, 0) / var(--uv-height, 1));
        // Pixelated rendering
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
        // Apply brightness
        filter: brightness(var(--face-brightness, 1));
    }
}

// Top face - horizontal plane rotated to face up
.faceTop {
    width: var(--face-width);
    height: var(--face-height);
    transform: translate(-50%, -50%)
        translate3d(var(--face-x), var(--face-y), var(--face-z, 0))
        rotateX(90deg);
}

// Left face (south) - vertical plane facing south
// translateZ pushes face to front of block, which lowers it after scene rotateX
.faceLeft {
    width: var(--face-width);
    height: var(--face-height);
    transform: translate(-50%, -50%)
        translate3d(var(--face-x), var(--face-y), var(--face-z, 0));
}

// Right face (east) - vertical plane facing east
.faceRight {
    width: var(--face-width);
    height: var(--face-height);
    transform: translate(-50%, -50%)
        translate3d(var(--face-x), var(--face-y), var(--face-z, 0))
        rotateY(90deg);
}
